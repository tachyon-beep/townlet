#!/usr/bin/env python
"""Generate CONFIG_REFERENCE.md from Pydantic config models.

Scans townlet.config.* domain modules (excluding loader and __init__) and
emits a Markdown reference with one section per model: fields, types,
defaults, and descriptions. Intended to keep docs in sync with the code.
"""
from __future__ import annotations

import argparse
import importlib
import inspect
import pkgutil
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Iterable

from pydantic import BaseModel


PACKAGE = "townlet.config"
EXCLUDE_MODULES = {"loader", "__init__"}


@dataclass
class FieldDoc:
    name: str
    type_str: str
    default: str
    description: str


def iter_config_modules() -> Iterable[str]:
    pkg = importlib.import_module(PACKAGE)
    package_path = Path(pkg.__file__).parent
    for module in pkgutil.iter_modules([str(package_path)]):
        name = module.name
        if name in EXCLUDE_MODULES:
            continue
        yield f"{PACKAGE}.{name}"


def is_model(obj: Any) -> bool:
    return (
        inspect.isclass(obj)
        and issubclass(obj, BaseModel)
        and not obj.__name__.startswith("_")
        and getattr(obj, "__module__", "").startswith(PACKAGE)
    )


def format_type(ann: Any) -> str:
    try:
        return getattr(ann, "__name__", None) or str(ann).replace("typing.", "")
    except Exception:  # pragma: no cover - best effort
        return str(ann)


def describe_model(model_cls: type[BaseModel]) -> list[FieldDoc]:
    docs: list[FieldDoc] = []
    for fname, finfo in model_cls.model_fields.items():
        ann = finfo.annotation
        type_str = format_type(ann)
        # default handling for pydantic v2
        if finfo.default_factory is not None:
            default_repr = "<factory>"
        elif finfo.default is not None:
            default_repr = repr(finfo.default)
        elif finfo.is_required():  # type: ignore[attr-defined]
            default_repr = "<required>"
        else:
            default_repr = "<none>"
        desc = (finfo.description or "").strip()
        docs.append(FieldDoc(fname, type_str, default_repr, desc))
    return docs


def render_markdown(models_by_module: dict[str, list[type[BaseModel]]]) -> str:
    lines: list[str] = []
    lines.append("# Configuration Reference (Generated)\n")
    lines.append("This file is generated by `scripts/gen_config_reference.py`. Do not edit manually.\n")
    lines.append("For an overview and examples, see docs/architecture_review/townlet-target-architecture.md.\n")
    for module_name, models in sorted(models_by_module.items()):
        if not models:
            continue
        lines.append(f"\n## {module_name}\n")
        for cls in sorted(models, key=lambda c: c.__name__):
            anchor = f"{module_name}.{cls.__name__}"
            doc = (cls.__doc__ or "").strip()
            lines.append(f"\n### {cls.__name__} ({module_name})\n")
            if doc:
                lines.append(f"{doc}\n")
            lines.append("| Field | Type | Default | Description |")
            lines.append("| --- | --- | --- | --- |")
            for fdoc in describe_model(cls):
                lines.append(
                    f"| `{fdoc.name}` | `{fdoc.type_str}` | `{fdoc.default}` | {fdoc.description or ''} |"
                )
            lines.append("")
    return "\n".join(lines) + "\n"


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--out", type=Path, default=Path("docs/guides/CONFIG_REFERENCE.md"))
    args = parser.parse_args()

    models_by_module: dict[str, list[type[BaseModel]]] = {}
    for module_name in iter_config_modules():
        module = importlib.import_module(module_name)
        models: list[type[BaseModel]] = []
        for _, obj in inspect.getmembers(module, is_model):
            models.append(obj)
        models_by_module[module_name] = models

    content = render_markdown(models_by_module)
    args.out.parent.mkdir(parents=True, exist_ok=True)
    args.out.write_text(content, encoding="utf-8")
    print(f"Wrote {args.out}")


if __name__ == "__main__":  # pragma: no cover - CLI entry
    main()
